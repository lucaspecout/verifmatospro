<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vérification matériel</title>
  <link rel="stylesheet" href="/static/styles.css" />
</head>
<body class="phone">
  <main class="phone-container">
    <section class="card check-hero">
      <div class="check-hero-header">
        <div>
          <p class="check-eyebrow">Vérification avant départ</p>
          <h1>{{ event.name }}</h1>
          <p class="check-subtitle">Poste de secours — checklist digitale synchronisée.</p>
        </div>
        <div class="check-progress-pill" id="public-progress">{{ progress.percent }}%</div>
      </div>
      <div class="progress" id="public-progress-bar">
        <div class="progress-bar" style="width: {{ progress.percent }}%"></div>
      </div>
      <div class="stats" id="public-progress-stats">
        <span class="stat-chip ok">OK: {{ progress.ok }}</span>
        <span class="stat-chip problem">Problèmes: {{ progress.problem }}</span>
        <span class="stat-chip pending">En attente: {{ progress.pending }}</span>
      </div>
      <div class="sync-pill">
        <span class="sync-dot"></span>
        Synchronisation instantanée active
        <span class="sync-time" id="public-last-sync">En attente</span>
      </div>
      <div class="sync-pill">
        Vérificateur: <strong>{{ verifier_name or 'Non renseigné' }}</strong>
      </div>
      <div class="divider"></div>
      <div class="pill pending" id="completion-banner">Checklist en cours</div>
    </section>

    <section class="card check-guide">
      <h2>Parcours rapide</h2>
      <div class="guide-steps">
        <div class="guide-step">
          <span>1</span>
          <div>
            <strong>Contrôle visuel</strong>
            <p>Vérifiez l'état et la quantité indiquée.</p>
          </div>
        </div>
        <div class="guide-step">
          <span>2</span>
          <div>
            <strong>Signaler un problème</strong>
            <p>Ajoutez un commentaire pour le chef de poste.</p>
          </div>
        </div>
        <div class="guide-step">
          <span>3</span>
          <div>
            <strong>Valider l'élément</strong>
            <p>Le suivi se met à jour instantanément.</p>
          </div>
        </div>
      </div>
    </section>

    <section class="card check-body" id="public-tree">
      {% for branch in tree %}
        {% include "partials/public_node.html" with context %}
      {% endfor %}
    </section>
  </main>

  <div class="modal" id="problem-modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="problem-title">
      <h2 id="problem-title" class="modal-title">Signaler un problème</h2>
      <p class="muted" id="problem-subtitle">Ajoutez un commentaire pour expliquer le souci.</p>
      <form class="modal-form">
        <label for="problem-comment">Commentaire</label>
        <textarea id="problem-comment" name="comment" rows="4" placeholder="Exemple : Manque de compresses."></textarea>
        <div class="modal-actions">
          <button class="btn ghost" type="button" data-action="cancel-problem">Annuler</button>
          <button class="btn danger" type="submit">Valider le problème</button>
        </div>
      </form>
    </div>
  </div>

  <script>
    const protocol = location.protocol === 'https:' ? 'wss' : 'ws';
    const ws = new WebSocket(`${protocol}://${location.host}/ws/events/{{ event.id }}`);

    const statusLabels = {
      ok: 'OK',
      problem: 'Problème',
      pending: 'En attente',
    };

    const updatePublicProgress = (progress) => {
      const bar = document.querySelector('#public-progress-bar .progress-bar');
      bar.style.width = `${progress.percent}%`;
      document.querySelector('#public-progress').textContent = `${progress.percent}%`;
      document.querySelector('#public-progress-stats').innerHTML = `
        <span class="stat-chip ok">OK: ${progress.ok}</span>
        <span class="stat-chip problem">Problèmes: ${progress.problem}</span>
        <span class="stat-chip pending">En attente: ${progress.pending}</span>
      `;
      const banner = document.querySelector('#completion-banner');
      if (banner) {
        if (progress.pending === 0) {
          banner.textContent = 'Checklist terminée ✅';
          banner.classList.add('ok');
          banner.classList.remove('pending');
        } else {
          banner.textContent = 'Checklist en cours';
          banner.classList.remove('ok');
          banner.classList.add('pending');
        }
      }
    };

    updatePublicProgress({{ progress | tojson }});

    const setNodeStatus = (node, status, comment) => {
      node.dataset.status = status || 'pending';
      node.classList.remove('ok', 'problem', 'pending');
      if (status) {
        node.classList.add(status);
      }
      const badge = node.querySelector('[data-role="status"]');
      if (badge) {
        badge.textContent = statusLabels[status] || status;
        badge.classList.remove('ok', 'problem', 'pending');
        if (status) {
          badge.classList.add(status);
        }
      }
      const input = node.querySelector('input[name="comment"]');
      if (input && typeof comment !== 'undefined') {
        input.value = comment || '';
      }
      if (typeof comment !== 'undefined') {
        node.dataset.comment = comment || '';
      }
      if (node.dataset.nodeType === 'container' && status === 'ok') {
        node.removeAttribute('open');
      }
    };

    const recomputeContainerStatus = (containerId) => {
      if (!containerId || containerId === 'root') {
        return;
      }
      const container = document.querySelector(`[data-node-id="${containerId}"]`);
      if (!container) {
        return;
      }
      const children = document.querySelectorAll(`[data-parent-id="${containerId}"]`);
      const statuses = Array.from(children).map((child) => child.dataset.status || 'pending');
      let nextStatus = 'pending';
      if (statuses.every((status) => status === 'ok')) {
        nextStatus = 'ok';
      } else if (statuses.some((status) => status === 'problem')) {
        nextStatus = 'problem';
      }
      setNodeStatus(container, nextStatus);
      recomputeContainerStatus(container.dataset.parentId);
    };

    const modal = document.querySelector('#problem-modal');
    const modalForm = modal?.querySelector('.modal-form');
    const modalTitle = document.querySelector('#problem-title');
    const modalSubtitle = document.querySelector('#problem-subtitle');
    const modalComment = document.querySelector('#problem-comment');
    const modalCancel = modal?.querySelector('[data-action="cancel-problem"]');
    let activeForm = null;

    const openModal = (node, form) => {
      if (!modal || !modalComment) {
        return;
      }
      activeForm = form;
      const nodeName = node?.dataset.nodeName || 'Équipement';
      modalTitle.textContent = `Problème — ${nodeName}`;
      modalSubtitle.textContent = 'Ajoutez un commentaire pour expliquer le souci.';
      modalComment.value = node?.dataset.comment || '';
      modal.classList.add('is-open');
      modal.setAttribute('aria-hidden', 'false');
      modalComment.focus();
    };

    const closeModal = () => {
      if (!modal) {
        return;
      }
      modal.classList.remove('is-open');
      modal.setAttribute('aria-hidden', 'true');
      activeForm = null;
    };

    const submitStatus = async (form, status, commentValue) => {
      const payload = new FormData();
      payload.append('status', status);
      payload.append('comment', commentValue || '');
      const response = await fetch(form.action, {
        method: 'POST',
        body: payload,
        headers: {
          'Accept': 'application/json',
        },
      });
      if (!response.ok) {
        form.submit();
        return;
      }
      const data = await response.json();
      const node = form.closest('[data-node-id]');
      if (node) {
        setNodeStatus(node, data.status, data.comment);
        recomputeContainerStatus(node.dataset.parentId);
      }
      if (data.progress) {
        updatePublicProgress(data.progress);
      }
      const syncTime = document.querySelector('#public-last-sync');
      if (syncTime) {
        const time = new Date().toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
        syncTime.textContent = `Mis à jour à ${time}`;
      }
    };

    const updateLoadDestination = (nodeId, vehicle, loaded = false) => {
      const target = document.querySelector(`.checklist-section[data-node-id="${nodeId}"]`);
      if (!target) {
        return;
      }
      const value = vehicle?.trim();
      target.dataset.loadVehicle = value || '';
      target.dataset.loaded = loaded ? 'true' : 'false';
      target.classList.toggle('loaded', loaded);
      const destination = target.querySelector('[data-role="load-destination"]');
      if (destination) {
        if (value) {
          destination.textContent = `Destination: ${value}`;
          destination.hidden = false;
        } else {
          destination.hidden = true;
        }
      }
    };

    document.querySelectorAll('.checklist-form').forEach((form) => {
      form.addEventListener('click', (event) => {
        const button = event.target.closest('button[data-status]');
        if (!button) {
          return;
        }
        event.preventDefault();
        const status = button.dataset.status;
        const node = form.closest('[data-node-id]');
        if (status === 'problem') {
          openModal(node, form);
          return;
        }
        const existingComment = form.querySelector('input[name="comment"]')?.value || '';
        submitStatus(form, status, existingComment);
      });
    });

    modalCancel?.addEventListener('click', () => {
      closeModal();
    });

    modal?.addEventListener('click', (event) => {
      if (event.target === modal) {
        closeModal();
      }
    });

    modalForm?.addEventListener('submit', (event) => {
      event.preventDefault();
      if (!activeForm) {
        closeModal();
        return;
      }
      submitStatus(activeForm, 'problem', modalComment?.value || '');
      closeModal();
    });

    document.querySelectorAll('.checklist-section[data-status="ok"]').forEach((node) => {
      node.removeAttribute('open');
    });

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.type === 'progress') {
        updatePublicProgress(data.progress);
        const node = document.querySelector(`[data-node-id="${data.node_id}"]`);
        if (node) {
          setNodeStatus(node, data.status, data.comment);
          recomputeContainerStatus(node.dataset.parentId);
        }
        const syncTime = document.querySelector('#public-last-sync');
        if (syncTime) {
          const time = new Date().toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
          syncTime.textContent = `Mis à jour à ${time}`;
        }
      }
      if (data.type === 'load') {
        updateLoadDestination(String(data.node_id), data.vehicle || '', Boolean(data.loaded));
      }
    };
  </script>
</body>
</html>
